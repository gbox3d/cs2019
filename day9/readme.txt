엔진 저장소로 이동 => cd c:\cs2019\cstudy 
최신버전으로 업데이트 => git pull

-------------------------------
포인터 279p

int a,b,c; => 기억공간
=> [1000],[2000],[2100]
=> a=1000 => [1000] =1000
b=2000 => [2000] = 2000
c=2100 => [2100] = 2100
=> 둘다 정수 => [하나]는 주소, 하나는 데이터

1. 주소 연산자 => & => scanf
=> a=200, b=100 
=> [100]=200, [200]=100
=> a-> 200 , &a->100 , [&a] -> 200 , [a]->100
=> b-> 100 , &b->200 , [&b] -> 100 , [b]->200

=> [[[a]]] -> ?

2^0 = 1 ,  2^-1 * 2^1 =>1-1 =0

2. 참조연산자(284p) => * => *주소 => [주소]

=> [100] => *100 => 200
=> a => *&a => 200

3. 포인터 변수 => int * =>참조 연산자를 써서 선언한 변수 


----------------------------------------------------
291p 포인터의 필요성
주소값을 얻어내는 연산자 => &
주소값이 가르키는 메모리안에 값을 얻어내는 연산자 => *

전역변수 사용하지않고 => return 안쓰고 =>
=> [포인터를 이용해서] 1씩 증가 시키는 함수를 만들어 보자
=> exam3 
=> 함수의 인자 전달 => 복사본 전달

=> 300p
=> 포인터 형=> 데이터 형


-------------------------------------------
a=b
mov ax ,dword ptr [b]
mov dword ptr[a] , ax

--------------------------------------------
포인터로 배열 다루기
int a[5]; => a[0]=1 , a[1]=2
=> a => a+1 == &(a[1])
=> a[1]=2 => *(a+1)=2

교재 316p 
*ptr => ptr[0],ptr[1] => *(ptr++) => *(ptr+i)

--------------------------------------------
포인터와 배열변수의 차이점
포인터=> 주소값을 저장하는 변수
배열 => 주소값을 저장하는 상수 

int *a; //변수
int a[3]; //상수

fucntion(int *a) //변수
fucntion(int a[]) //변수

--------------------------------------------

1 접속자=> 쓰래드 1개
100 => 쓰래드 100 => 4코어 =25대
100 => 쓰래드 1개 =1 대

----------------------------------------------
TGE eaxm2 

















