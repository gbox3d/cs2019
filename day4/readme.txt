문자(char) 데이터 처리, 84p
어제배웠던 데이터 다루는 법=> 숫자
=> 정수, 실수
=> int, double(float)
=> int(4byte), double(8byte) => bit,byte
=> char(1 byte)
=> word(2byte) => dword(4byte) => ddword(8)
=> 1001 => 8421 
=> (1,0,0,1) * (8,4,2,1) = (1*8)+(0*4)+(0*2)+(1*1) = 9
=> 0000 => 0
=> 1111 => 15(f) => 9..10 => 9..a b c d e f
=> 0000 0000 => 00 =>  
=> 1111 1111 => 00~ff => 1byte
=> ff => (128,64,32,16, 8,4,2,1) => 0~255
=> 1 byte=> 1 문자(아스키코드 기준)
=> 2 byte => 0~65535

--------------------------------------
파워쉘 사용하기
검색아이콘 클릭=> power shell입력
=> windows PowerShell앱실행=> cmd 사용법과 유사.
=> dir(ls), copy(cp),move(mv), del(rm)

---------------------------------------------
우측 솔루션 탐색기=>프로잭트=>헤더파일폴더=>pch.h오픈
=> #include <stdio.h>

----------------------------------------
char => '문자' => "문자열"
=> int(%d) double(lf%) 
=> char(%c)
const char *,char []=> 문자열
=> 출력=> %s
=> 입력 => scanf_s 
=> 3번째 인자에 입력버퍼의 바이트수 반드시 기입
=> scanf_s("%c",&_c,1) => 여기서 1은 1바이트를 뜻함

TCHAR => wide char vs mult byte
TCHAR => char->TCHAR , TCHAR->char
stl::string

=> sprintf => 문자열로 결과를 출력
=> sscanf => 키보드가 아닌 형식화된 문자열로 부터 입력
=> sscanf_s => 문자나 문자열 입력 받을때는 => 연달아서 버퍼의 크기도 명시해야함.

-----------------------------------------------------
형변환 연산자(type casting)
명시적으로 형을 지정할때 사용됨
=>암시적으로 지정된 데이터형은 예상하지못한 값이 나올수 있다. 
=> double num = 5/2 
=> num 예상은 2.5이나 실재로 받는 데이터는 2.0
=>가장 혼동하기 쉬운 부분 
=> 주의 요망 => 중요한 버그는 여기서 50%이상나옴.
100p 문제 풀어보세요(해답은 나중에보시고)

-------------------------------------------------------
진법을 바꿔 출력 => printf => 
%o -> 8진수
%d -> 10진수
%x -> 16진수 => 2진수 출력은 어떻게???

2byte 자료형=> short(2) => int(4) => 8,16,32,64,
=> 8,16비트 시절 => int은 16비트(2바이트)
=> 하위호환 목적으로 short타입 유지(WORD) 
=> DWORD(4), DDWORD(8)
=> char => 1 바이트 정수형

---------------------------------------------------
나누기 결과를 몫,나머지 구하기
=> 정수 / 정수 = 몫
=> 정수 % 정수 = 나머지 
------------------------------------------
부호의 표현 =>첫비트가 0이면 + ,1 이면 -
0000 => 0
0001 => 1
0010 => 2
....

0111 => 7
1000 => 8 => -8
....
1110 => 14 => -2
1111 => 15 => -1
------------------------------------------
exam8

실수의 표현법
=> 지수 표현법 => 1.0e3 -> 1000
=> 100 => 1.0e2
=> 1.0e-2 => 0.01

=> 실수의 비트표현 => 8바이트 기준(64bit) => 
첫번째 비트(부호비트) , 나머지 63비트 실수를 표현
=> 11비트 지수값, 나머지 52비트 소수값(유효숫자)
=> 2^52 , 2^11

=> cpu , fpu ,gpu 
=> 0.1 => 1000(1), 100(0.1), 10(0.01) ,1(0.001)
=> doom 
---------------------------------------------------
sizeof(데이터형 | 변수) => 크기를 반환

printf 응용=> 부호없이 출력=> 부호%d , 부호없음%u

유니코드 문자 출력 => \u16진수유니코드 => \u2660

숙제 : 155p ,5-3, 액셀처럼 만들기 
----------------------

































